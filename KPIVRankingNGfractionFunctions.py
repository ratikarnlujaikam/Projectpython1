##############################################################################
# This file collects all functions that are necessary to establish a         #
# separate ranking of continuous and categorical KPIVs based on the alignment#
# between the local NG fraction and the histogram of the KPIV. From these    #
# both curves several quantities are derived that can be viewed as criteria  #
# how well the curves are aligned. With two different algorithms these       #
# criteria are combined into one overall criterion for that alignment, which #
# estalishes a ranking of the KPIVs. This ranking identifies those KPIVs     #
# that are not optimally adjusted. It is not a measure of the KPIVs          #
# influence on the KPOV! Details of the employed mathematical algorithms can #
# be found in the description of the individual functions.                   #
#                                                                            #
# Many of the functions in this file check the validity of their input       #
# arguments and throw a ValueError as an exception, if the requirements are  #
# not fulfilled. A description of the potential exceptions can be found in   #
# the corresponding function description. If these exceptions are not caught,#
# the program will crash. Therefore, it is highly recommended that a program,#
# which calls some of the functions in this file, should catch the potential #
# exceptions and handle them appropriately.                                  #
#                                                                            #
# Several functions from the packages numpy and matplotlib are used, i. e.   # 
# these packages must be installed.                                          #
#                                                                            #
##############################################################################
#                                                                            #
# Author: Werner Karpen, created 21.08.2023                                  #
#                                                                            #
##############################################################################
import numpy as np
import pandas as pd
import NGfractionRankingCriteriaFunctions as NGfracFun
import DataScienceUtilityFunctions as Utility
import DataSciencePreprocessingFunctions as Prepro
import NGfractionAdaptionFunctions as NGAdapt
#import time

##############################################################################
########################### KPIVRankingNGfraction ############################
##############################################################################
def KPIVRankingNGfraction(DataKPIVIn,DataKPOVIn,specValue,specLimits,nBins=-1,minCounts=-1,nSelected=-1,nWeights=-1,nTrials=20,
                          ngFracDesired=-1,nSeparationOutlierSmote=1000,nDefaultNG=10000,CriteriaLimits=np.empty((0,0)),
                          statisticalMethod=0,bAdapted=1,UseNGfracError=0,VariableNamesForBarcodes=np.array(['Barcode']),
                          reliabilityLimitsRanking=np.array([2.0,4.0]),reliabilityLimitsSignificant=np.array([2,4]),
                          tol=1.0e-12,tolZero=1.0e-12,nMinBins=4,tolInt=1.0e-12,tolUniform=0.8):
#Determination of a separate ranking for continuous and categoricak KPIVs
#based on the NG fraction.
#
#   A separate ranking of the continuous and categorical KPIVs of DataKPIVIn 
#   is derived from several ranking criteria, which are based on the  
#   alignment of the local NG fraction with the histogram of the KPIVs. The 
#   different ranking criteria are combined into one value by averaging. 
#   Each ranking criterion is scaled to a certain range (usually [0,1]), so 
#   that they are comparable. Thus, the average over all ranking criteria 
#   establishes a ranking of the KPIVs by averaging.
#   The error of the ranking is quantified by repeating the evaluation with
#   slightly different numbers NG parts in the bins. These are generated by 
#   a random number generator for the Binomial distribution, because we 
#   assume that the number of NG parts in each bin obeys a Binomial 
#   distribution.
#   If the number of true NG parts is too small for a reliable ranking,
#   additional artificial NG parts are generated either by defining outlier
#   limits or by the SMOTE algorithm. Which method is used, is determined
#   automatically.
#   Furthermore, categorical KPIVs are automatically identified.
#
#   function input:
#      DataKPIVIn: Sample data from which the histogram should be derived. 
#                  It has dimension (nData,nPar), where nData is the number 
#                  of data sets and nPar the number of KPIVs.
#      DataKPOVIn: Sample data for the KPOV, from which the classification
#                  in good and NG parts is derived. It has dimension
#                  (nData,1) or (1,nData).
#      specValue: The spec value for the KPOV. It is used to define
#                 outliers, if there are not enough true NG parts.
#      specLimits: The spec limits for the KPOV. These are used to define
#                  the true NG parts.
#      There are additional optional input arguments collected in varargin.
#      nBins=varargin{1}: Desired number of bins. The true number of bins 
#                 in the generated histogram might be smaller for 
#                 pathological cases. If nBins<1, Sturges'rule will be 
#                 applied, i. e. nBins=1+log2(nData).
#      minCounts=varargin{2}: The allowed minimum number of counts in one  
#                 bin. Obviously, if nData<minCount, it is impossible to 
#                 fulfill this requirement. If minCounts is negative, the 
#                 following empirical rule will be applied: 
#                 minCounts=0.05*nData.
#      nSelected=varargin{3}: Thew number of central bins that should be 
#                 taken into account for the determination of the ranking 
#                 criteria. If it is larger than nBins, all bins will be 
#                 selected. If it is smaller than 2, nBins/2 bins will 
#                 selected.
#      nWeights=varargin{4}: The number of features that should be taken 
#                 into account for majority voting. It has to be smaller 
#                 than or equal to the number of features. If it is larger 
#                 than nPar or smaller than 1, we set nWeights=nPar/5.
#      nTrials=varargin{5}: The number of runs for the estimation of the 
#                 ranking error. The default value is nTrials=20. If
#                 nTrials=1, no ranking error can be determined.
#      ngFracDesired=varargin{6}: The desired fraction of NG parts for a
#                 reliable ranking of the KPIVs. If the true NG fraction is
#                 smaller, additional artificial NG parts are generated
#                 either by the SMOTE algorithm or by defining outliers. If
#                 ngFracDesired is larger than 1, the value 0.5 will be
#                 used. If it is smaller than zero, an optimum value will
#                 be determined depending on the desired number of NG
#                 parts.
#      nSeparationOutlierSmote=varargin{7}: The number of true NG parts,
#                 where the switch-over from outliers to the SMOTE 
#                 algorithm takes place. Below it additional artificial NG
#                 parts are generated by defining oulier limits, above it
#                 the SMOTE alforithm will be used. The default value is
#                 1000.
#      nDefaultNG=varargin{8}: The number of total NG parts (including 
#                 artificially generated ones) that should be reached. At
#                 least 10 % of it have to be reached. The default value is
#                 10000.
#      CriteriaLimits=varargin{9}: A 2d array of size (2,number of criteria) 
#                 with the minimum and maximum value for each criterium, 
#                 which are used to scale the ranking criteria into the 
#                 interval [0,1]. This might be helpful to compare ranking 
#                 criteria from different times.
#      statisticalMethod=varargin{10}: This function argument controls the
#                 method that is used for calculating the histogram and the
#                 local NG fraction. The following values are allowed:
#                 statistcalMethod<0.5: The parts parts in the bins are 
#                                       counted (default).
#                 statistcalMethod>=0.5: The kernel density approximation
#                                       is applied (approximation by radial
#                                       basis functions).
#      bAdapted=varargin{11}: This function argument controls, if the 
#                 histogram should have adapted bin sizes. The following 
#                 values are allowed:
#                 bAdapted<0.5: The bin sizes are equal. In this case the
#                               function input minCounts is ignored.
#                 bAdapted>=0.5: The bin sizes are adapted to the number of 
#                                parts in the bins (default).
#      UseNGfracError=varargin{12}: This function argument controls, if the 
#                 error of the local NG fraction should be used to weight 
#                 the credibility of the calculated ranking criteria for 
#                 each KPIV. The following values are allowed:
#                 UseNGfracError<0.5: Weighting factor 1 (no weighting=default).
#                 0.5<=UseNGfracError<1.5: Weighting with the reciprocal of 
#                               the absolute error of the local NG fraction.
#                 1.5<=UseNGfracError<2.5: Weighting with the square root 
#                               of the number of bins divided by the 
#                               absolute error of the local NG fraction.
#                 UseNGfracError>=2.5: Weighting with the square root 
#                               of the number of bins divided by the 
#                               relative error of the local NG fraction.
#      VariableNamesForBarcodes=varargin{13}: Names of columns that contain
#                 barcodes, which should be used for making the data unique. 
#                 It could also be empty. The default value is Barcode.
#      reliabilityLimitsRanking=varargin{14}: A 2d array of size (2,1) 
#                 with the limiting values of the ranking error, which 
#                 separate good, medium and bad reliability of the ranking.
#      reliabilityLimitsSignificant=varargin{15}: A 2d array of size (2,1) 
#                 with the limiting values of the error for the number of 
#                 significant KPIVs, which separate good, medium and bad 
#                 reliability of the ranking.
#      tol=varargin{16}: The tolerance (relative or absolute) for the 
#                 equality of floating point values. The default value is
#                 1.0e-12.
#      tolZero=varargin{17}: The limit, below which a floating point number
#                 be viewed as zero. It determines whether relative or
#                 absolute tolerance will be used for equality checking. 
#                 The default value is 1.0e-12.
#      nMinBins=varargin{18}: The minimum number of bins for the histogram
#                 of a continuous KPIV. The default value is 4.
#      tolInt=varargin{19}: The tolerance for the definition of integer 
#                 values. If deviation from a true integer value is smaller
#                 than tolInt, the number will be viewed as an integer. The
#                 default value is 1.0e-12.
#      tolUniform=varargin{20}: The tolerance for the definition of a 
#                 uniform distibution. If the difference between maximum and
#                 minimum of the histogram divided by its mean is smaller 
#                 than tolUniform, the KPIV will be viewed as categorical. 
#                 The default value is 0.8.
#
#   function output:
#      RankingResultsContinuous: Information about the ranking of 
#                                continuous KPIVs and its error derived 
#                                from averaging.
#      RankingResultsCategorical: Information about the ranking of 
#                                 categorical KPIVs and its error derived 
#                                 from averaging.
#         The ranking structure is a Matlab structure that collects the
#         results of the ranking and its error. The following quantities 
#         are contained:
#            KPIVRanking: The names of the KPIVs ranked according to their
#                   importance.
#            RankingError: The ranking error for each KPIV estimated 
#                   from statistical considerations.
#            nSignificant: The number of significant KPIVs that have an
#                   influence on the NG fraction.
#            nSignificantError: The error of the number of significant 
#                   KPIVs estimated from statistical considerations.
#            rankingErrorAverage: The global ranking error estimated from 
#                   statistical considerations. It is defined as the mean
#                   of the ranking error of the significant KPIVs.
#            reliability: A judgement for the reliability of the ranking 
#                   ranging from "very good", "good", "medium", "bad" to 
#                   "very bad". It is derived from a combination of 
#                   rankingErrorAverage and nSignificantError. 
#
#   Exceptions:
#      DataKPIVIn empty: If there are no sample data, an exception is 
#               thrown with the message: 
#                     "The array of sample data must not be empty!"
#      nData too small: If the number of sample data is smaller than a 
#               specified minimum, an exception is thrown with the message: 
#                     "The number of sample data is too small for a 
#                      meaningful evaluation!"
#      DataKPOVIn not 1d: If the array for the KPOV data is not 1d, 
#               an exception is thrown with the message: 
#                     "The array of KPOV data has to be 1d!"
#      nKPOV~=nData: If the size of the KPOV data does not fit to the size 
#               of the sample data, an exception is thrown with the message: 
#                     "The array of sample data must have the same length 
#                      as the array of KPOV data!"
#      specLimits not 1d: If the array for the spec limits of the KPOVs is 
#               not 1d, an exception is thrown with the message: 
#                     "The array of spec limits has to be 1d!"
#      numel(specLimits)~=2: If the size of the spec limits is not 2, an 
#               exception is thrown with the message: 
#                     "The array of spec limits must have 2 elements!"

    #### default value for desired NG fraction that will be used, if 
    #### ngFracDesired is not specified
    fracDefaultNG=0.1; 
    
    ##################### check for correct data format and input parameter
    ##################### check for correct data format and input parameter
    if isinstance(DataKPIVIn,pd.DataFrame):
        ##################### code for pandas dataframe
        if DataKPIVIn.empty:
            errStr="Error in KPIVRankingNGfraction: The array of sample data must not be empty!"
            raise ValueError(errStr)
        shapeData=DataKPIVIn.shape
        nData=shapeData[0]
        try: nPar = shapeData[1]
        except: nPar = 1
    else:
        ##################### code for numpy array
        if np.size(DataKPIVIn)<1:
            errStr="Error in KPIVRankingNGfraction: The array of sample data must not be empty!"
            raise ValueError(errStr)
        shapeData=np.shape(DataKPIVIn)
        nData=shapeData[0]
        try: nPar = shapeData[1]
        except: nPar = 1
    if nData<0.1*nDefaultNG:
        errStr="Error in KPIVRankingNGfraction: The number of sample data is too small for a meaningful evaluation!"
        raise ValueError(errStr)

    nLabels=np.size(DataKPOVIn)
    if np.squeeze(DataKPOVIn).ndim>1:
        errStr="Error in KPIVRankingNGfraction: The array of KPOV data has to be 1d!"
        raise ValueError(errStr)
    if nLabels!=nData:
        errStr="Error in KPIVRankingNGfraction: The array of sample data must have the same length as the array of KPOV data!"
        raise ValueError(errStr)
    shapeData=np.shape(specLimits)
    n1=shapeData[0]
    try: n2 = shapeData[1]
    except: n2 = 1
    if n1==1 and n2>1: # specLimits is a row vector
        n1=n2;
        n2=1;
        specLimits=np.transpose(specLimits)
    if n2!=1:
        errStr="Error in KPIVRankingNGfraction: The array of spec limits has to be 1d!"
        raise ValueError(errStr)
    if n1!=2:
        errStr="Error in KPIVRankingNGfraction: The array of spec limits must have 2 elements!"
        raise ValueError(errStr)
    
    ##################### choose default values for inappropriate function
    ##################### input
    if ngFracDesired>1:
        ngFracDesired=0.5;
    if ngFracDesired<0:
        if nDefaultNG/nData<fracDefaultNG:
            ngFracDesired=fracDefaultNG;
        if nDefaultNG/nData>=fracDefaultNG and nDefaultNG/nData<2.0*fracDefaultNG:
            ngFracDesired=nDefaultNG/nData;
        if nDefaultNG/nData>=2.0*fracDefaultNG:
            ngFracDesired=2.0*fracDefaultNG;
    if ngFracDesired*nData<0.1*nDefaultNG:
        ngFracDesired=(0.1*nDefaultNG)/nData;
    
    ############## determine KPIV names
    if isinstance(DataKPIVIn,pd.DataFrame):
        KPIVNamesAll=np.array(DataKPIVIn.columns)
    else:
        KPIVNamesAll=list({})
        for n in range(0,nPar):
            tmpStr='Parameter'+str(n)
            KPIVNamesAll.append(tmpStr)
    KPIVNamesAll=np.array(KPIVNamesAll)
    
    ############## clean data
    DataKPIVCleaned,indKPIVsKept,_,indRowsKept = Prepro.CleanDataForKPIVRanking(DataKPIVIn,tol,tolZero,VariableNamesForBarcodes);
    
    ############## determine categorical KPIVs
    _,indCategoricalKPIVs=Prepro.FindCategoricalKPIVs(DataKPIVCleaned,nMinBins,tolInt,tolUniform); # determine which KPIVs are categorical
    ContinuousKPIVFlags=np.ones((nPar,1))
    ContinuousKPIVFlags[indCategoricalKPIVs]=0;
    
    ############## determine true global NG rate
    posNGTrue=np.argwhere(np.logical_or(DataKPOVIn[indRowsKept]<specLimits[0] , DataKPOVIn[indRowsKept]>specLimits[1]))[:,0];
    nNGTrue=np.size(posNGTrue);
    ngFracGlobalTrue=nNGTrue/nData;
    
    ############## calculate class labels
    if ngFracGlobalTrue<ngFracDesired: # we have not enough true NG parts
        if nNGTrue<nSeparationOutlierSmote or np.size(indCategoricalKPIVs)>0: # use outlier limits to define more NG parts
            ClassLabels=NGAdapt.GenerateClassLabelsForNGRankingOutlier(DataKPOVIn[indRowsKept],specValue,specLimits,ngFracDesired);
            DataKPIVSmote=np.array([]);
        else: # use SMOTE to generate more NG parts
            ClassLabels,DataKPIVSmote=NGAdapt.GenerateClassLabelsForNGRankingSmote(DataKPIVCleaned,DataKPOVIn[indRowsKept],specLimits,ngFracDesired,indCategoricalKPIVs);
    else: # use true NG parts
        ClassLabels=np.ones((nSamples,1))
        ClassLabels[posNGTrue]=-1.0;
    
    ############## determine ranking for continuous and categorical KPIVs
    # collect optional input
    _,RankingStructureAveragingContinuous,_,RankingStructureAveragingCategorical,_,_,_,TypeOfKPIV = ParameterRankingNGfraction(DataKPIVCleaned,DataKPIVSmote,ClassLabels,ContinuousKPIVFlags,
                                                                    nBins,minCounts,nSelected,nWeights,nTrials,CriteriaLimits,statisticalMethod,bAdapted,UseNGfracError,nMinBins,tolUniform);
    ##################### some of the continous KPIVs might have been coverted
    ##################### to categorical
    indContinuousKPIVs=np.argwhere(TypeOfKPIV>0.5)[:,0];
    indCategoricalKPIVs=np.argwhere(TypeOfKPIV<=0.5)[:,0];
    
    ############## prepare results for presentation in frontend
    ############## for continuous KPIVs
    KPIVNamesCleaned=KPIVNamesAll[indKPIVsKept];
    KPIVNamesContinuous=KPIVNamesCleaned[indContinuousKPIVs];
    RankingResultsContinuous=InitOutputStructureRanking()
    if np.size(RankingStructureAveragingContinuous["ParameterRanking"])>0 and np.size(RankingStructureAveragingContinuous["ParameterRanking"])==np.size(indContinuousKPIVs):
        RankingResultsContinuous["KPIVRanking"]=KPIVNamesContinuous[RankingStructureAveragingContinuous["ParameterRanking"]];
    if np.size(RankingStructureAveragingContinuous["errorRankingKPIV"])>0 and np.size(RankingStructureAveragingContinuous["errorRankingKPIV"])==np.size(indContinuousKPIVs):
        temp=RankingStructureAveragingContinuous["errorRankingKPIV"]
        RankingResultsContinuous["RankingError"]=temp[RankingStructureAveragingContinuous["ParameterRanking"]];
    RankingResultsContinuous["nSignificant"]=RankingStructureAveragingContinuous["nSignificant"];
    RankingResultsContinuous["nSignificantError"]=RankingStructureAveragingContinuous["errorSignificant"];
    RankingResultsContinuous["rankingErrorAverage"]=RankingStructureAveragingContinuous["errorRanking"];
    if RankingResultsContinuous["rankingErrorAverage"]>-0.1 and RankingResultsContinuous["nSignificantError"]>-0.1:
        RankingResultsContinuous["reliability"]=JudgeRankingReliability(RankingResultsContinuous["rankingErrorAverage"],RankingResultsContinuous["nSignificantError"],reliabilityLimitsRanking,reliabilityLimitsSignificant);
    
    
    ############## prepare results for presentation in frontend
    ############## for categorical KPIVs
    KPIVNamesCategorical=KPIVNamesCleaned[indCategoricalKPIVs];
    RankingResultsCategorical=InitOutputStructureRanking()
    if np.size(RankingStructureAveragingCategorical["ParameterRanking"])>0 and np.size(RankingStructureAveragingCategorical["ParameterRanking"])==np.size(indCategoricalKPIVs):
        RankingResultsCategorical["KPIVRanking"]=KPIVNamesCategorical[RankingStructureAveragingCategorical["ParameterRanking"]];
    if np.size(RankingStructureAveragingCategorical["errorRankingKPIV"])>0 and np.size(RankingStructureAveragingCategorical["errorRankingKPIV"])==np.size(indCategoricalKPIVs):
        temp=RankingStructureAveragingCategorical["errorRankingKPIV"]
        RankingResultsCategorical["RankingError"]=temp[RankingStructureAveragingCategorical["ParameterRanking"]];
    RankingResultsCategorical["nSignificant"]=RankingStructureAveragingCategorical["nSignificant"];
    RankingResultsCategorical["nSignificantError"]=RankingStructureAveragingCategorical["errorSignificant"];
    RankingResultsCategorical["rankingErrorAverage"]=RankingStructureAveragingCategorical["errorRanking"];
    if RankingResultsCategorical["rankingErrorAverage"]>-0.1 and RankingResultsCategorical["nSignificantError"]>-0.1:
        RankingResultsCategorical["reliability"]=JudgeRankingReliability(RankingResultsCategorical["rankingErrorAverage"],RankingResultsCategorical["nSignificantError"],reliabilityLimitsRanking,reliabilityLimitsSignificant);
    
    return RankingResultsContinuous,RankingResultsCategorical
##############################################################################
######################### end KPIVRankingNGfraction ##########################
##############################################################################



##############################################################################
######################## ParameterRankingNGfraction ##########################
##############################################################################
def ParameterRankingNGfraction(DataIn,DataSmote,ClassLabelsIn,TypeOfKPIV,nBins=-1,
                               minCounts=-1,nSelected=-1,nWeights=-1,nTrials=20,
                               xExtrema=np.empty((0,0)), statistcalMethod=0,
                               bAdapted=1,UseNGfracError=0,nMinBins=4,tolUniform=0.8):
#ParameterRankingNGfraction:   Determine a ranking of continuous and 
#categorical input parameter based on several ranking criteria.
#
#   A separate ranking of the continuous and categorical KPIVs of DataIn is 
#   derived from several ranking criteria, which are based on the alignment 
#   of the local NG fraction with the histogram of the KPIVs. The different 
#   ranking criteria are combined into one value by two different methods, 
#   namely majority voting and averaging. For majority voting we sort the 
#   KPIVs in descending order according to their importance. This gives a
#   different order for each ranking criterion. The first nWeights KPIVs
#   are assigned with descending weights from nWeights to 1. The sum of
#   these weights over all criteria establishes a ranking by majority 
#   voting. In the second method each ranking criterion is scaled to a
#   certain range (usually [0,1]), so that they are comparable. Thus, the
#   average over all ranking criteria establishes a ranking of the KPIVs by
#   averaging.
#   The error of the ranking is quantified by repeating the evaluation with
#   slightly different numbers NG parts in the bins. These are generated by 
#   a random number generator for the Binomial distribution, because we 
#   assume that the number of NG parts in each bin obeys a Binomial 
#   distribution.
#
#   function input:
#      DataIn: Sample data from which the histogram should be derived. It 
#              has dimension (nData,nPar), where nData is the number of 
#              data sets and nPar the number of KPIVs.
#      DataSmote: Sample data generated by the SMOTE algorithm. It should
#                 only be used for the NG fraction in the bins, because the
#                 true distribution has been altered due to the generation
#                 of additional NG parts. It has to be empty, if no SMOTE 
#                 data will be used. If it is not empty, it has dimension 
#                 (nDataSmote,nPar).
#      CLassLabelsIn: Labels for a binary classification of the sample data. 
#                     The label (-1) indicates ng parts, whereas the label 
#                     (+1) indicates good parts. The array must have  
#                     dimension (nData,1) or (1,nData), if no SMOTE data 
#                     are used, otherweise (nDataSmote,1) or (1,nDataSmote).
#      TypeOfKPIV: A boolean array of dimension (nPar,1) or (1,nPar) that
#                  determines for each KPIV, if it is continuous (1=true)
#                  or categorical (0=false).
#      nBins: Desired number of bins. The true number of bins in the
#             generated histogram might be smaller for pathological cases.
#             If nBins<1, Sturges'rule will be applied, i. e. 
#             nBins=1+log2(nData).
#      minCounts: The allowed minimum number of counts in one bin.  
#                 Obviously, if nData<minCount, it is impossible to fulfill
#                 this requirement. If minCounts is negative, the following
#                 empirical rule will be applied: minCounts=0.05*nData.
#      nSelected: Thew number of central bins that should be taken into 
#                 account for the determination of the ranking criteria. If 
#                 it is larger than nBins, all bins will be selected. If it
#                 is smaller than 2, nBins/2 bins will selected.
#      nWeights: The number of features that should be taken into account 
#                for majority voting. It has to be smaller than or equal to
#                the number of features. If it is larger than nPar or 
#                smaller than 1, we set nWeights=nPar/5.
#      There are additional optional input arguments collected in varargin.
#      nTrials=varargin{1}: The number of runs for the estimation of the 
#                ranking error. The default value is nTrials=20. If
#                nTrials=1, no ranking error can be determined.
#      varargin{2}: A 2d array of size (2,number of criteria) with the
#                 minimum and maximum value for each criterium, which are 
#                 used to scale the ranking criteria into the interval [0,1].
#                 This might be helpful to compare ranking criteria 
#                 from different times.
#      statistcalMethod=varargin{3}: This function argument controls the
#                 method that is used for calculating the histogram and the
#                 local NG fraction. The following values are allowed:
#                 statistcalMethod<0.5: The parts parts in the bins are 
#                                       counted (default).
#                 statistcalMethod>=0.5: The kernel density approximation
#                                       is applied (approximation by radial
#                                       basis functions).
#      bAdapted=varargin{4}: This function argument controls, if the 
#                 histogram should have adapted bin sizes. The following 
#                 values are allowed:
#                 bAdapted<0.5: The bin sizes are equal. In this case the
#                               function input minCounts is ignored.
#                 bAdapted>=0.5: The bin sizes are adapted to the number of 
#                                parts in the bins (default).
#      UseNGfracError=varargin{5}: This function argument controls, if the 
#                 error of the local NG fraction should be used to weight 
#                 the credibility of the calculated ranking criteria for 
#                 each KPIV. The following values are allowed:
#                 UseNGfracError<0.5: Weighting factor 1 (no weighting=default).
#                 0.5<=UseNGfracError<1.5: Weighting with the reciprocal of 
#                               the absolute error of the local NG fraction.
#                 1.5<=UseNGfracError<2.5: Weighting with the square root 
#                               of the number of bins divided by the 
#                               absolute error of the local NG fraction.
#                 UseNGfracError>=2.5: Weighting with the square root 
#                               of the number of bins divided by the 
#                               relative error of the local NG fraction.
#      nMinBins=varargin{6}: The minimum number of bins for the histogram
#              of a continuous KPIV. The default value is 4.
#      tolUniform=varargin{7}: The tolerance for the definition of a 
#              uniform distibution. If the difference between maximum and
#              minimum of the histogram divided by its mean is smaller 
#              than tolUniform, the KPIV will be viewed as categorical. 
#              The default value is 0.8.
#
#   function output:
#      RankingStructureVoting: Information about the ranking of the KPIVs 
#                              and its error derived from majority voting.
#      RankingStructureAveraging: Information about the ranking of the 
#                                 KPIVs and its error derived from 
#                                 averaging.
#         The ranking structure is a Matlab structure that collects the
#         results of the ranking and its error. The following quantities 
#         are contained:
#            ParameterRanking: The ranking of the KPIVs.
#            GlobalCriterion: The combined ranking criteria for each KPIV, 
#                   which are the basis of the ranking.
#            nSignificant: The number of significant KPIVs that have an
#                   influence on the NG fraction.
#            errorSignificant: The error of the number of significant KPIVs 
#                   estimated from statistical considerations.
#            errorRankingKPIV: The ranking error for each KPIV estimated 
#                   from statistical considerations.
#            errorRanking: The global ranking error estimated from 
#                   statistical considerations. It is defined as the mean
#                   of the ranking error of the significant KPIVs.
#      RankingCriteriaPar: The values of all ranking criteria with 
#                          weigthing for each KPIV. It has dimension
#                          (nPar,nCriteria).
#      RankingCriteriaLimitsContinuous: A 2d array of size (2,nCriteria) 
#                                       with the minimum and maximum value 
#                                       for each criterium, which are used 
#                                       to scale the ranking criteria of 
#                                       the continuous KPIVs into the 
#                                       interval [0,1].
#      RankingCriteriaLimitsCategorical: A 2d array of size (2,nCriteria) 
#                                        with the minimum and maximum value 
#                                        for each criterium, which are used 
#                                        to scale the ranking criteria of 
#                                        the continuous KPIVs into the 
#                                        interval [0,1].
#
#   Exceptions:
#      DataIn empty: If there are no sample data, an exception is thrown 
#               with the message: 
#                     "The array of sample data must not be empty!"
#      ClassLabelsIn not 1d: If the array for the class labels is not 1d, 
#               an exception is thrown with the message: 
#                     "The array of class labels has to be 1d!"
#      nKPIVSmote~=nPar: If the number of KPIVs of the SMOTE data does not 
#               fit to the number of KPIVs  of the sample data, an  
#               exception is thrown with the message: 
#                     "The number of KPIVs must be the same for sample and 
#                      SMOTE data!"
#      nClassLabels~=nDataSmote: If the size of the class labels does not 
#               fit to the size of the sample data, an exception is thrown 
#               with the message: 
#                     "The array of sample data must have the same length 
#                      as the array of class labels!"
#      TypeOfKPIV not 1d: If the array for the type of the KPIVs is not 1d, 
#               an exception is thrown with the message: 
#                     "The array of KPIV types has to be 1d!"
#      nTypes~=nPar: If the size of the KPIV types does not fit to the size 
#               of the sample data, an exception is thrown with the message: 
#                     "The array of KPIV types must have the same length 
#                      as the second dimension of the sample data!"
    import HistogramWithNGfractionFunctions as HistNG

    ##################### Presently for continuous KPIVs only 4 criteria are
    ##################### stable enough for a reliable ranking, for categorical
    ##################### KPIVs only 2 are stable enough
    nCriteriaContinuous=4;
    nCriteriaCategorical=2;
    
    ##################### check for correct data format and input parameter
    if isinstance(DataIn,pd.DataFrame):
        ##################### code for pandas dataframe
        if DataIn.empty:
            errStr="Error in ParameterRankingNGfraction: The array of sample data must not be empty!"
            raise ValueError(errStr)
        shapeData=DataIn.shape
        nData=shapeData[0]
        try: nPar = shapeData[1]
        except: nPar = 1
    else:
        ##################### code for numpy array
        if np.size(DataIn)<1:
            errStr="Error in ParameterRankingNGfraction: The array of sample data must not be empty!"
            raise ValueError(errStr)
        shapeData=np.shape(DataIn)
        nData=shapeData[0]
        try: nPar = shapeData[1]
        except: nPar = 1
    if isinstance(DataSmote,pd.DataFrame):
        ##################### code for pandas dataframe
        if DataSmote.empty:
            bSmote=0;
        else:
            shapeData=DataSmote.shape
            nDataSmote=shapeData[0]
            try: n2 = shapeData[1]
            except: n2 = 1
            if n2!=nPar:
                errStr="Error in ParameterRankingNGfraction: The number of KPIVs must be the same for sample and SMOTE data!"
                raise ValueError(errStr)
            bSmote=1;
    else:
        ##################### code for numpy array
        if np.size(DataSmote)<1:
            bSmote=0;
        else:
            shapeData=np.shape(DataSmote)
            nDataSmote=shapeData[0]
            try: n2 = shapeData[1]
            except: n2 = 1
            if n2!=nPar:
                errStr="Error in ParameterRankingNGfraction: The number of KPIVs must be the same for sample and SMOTE data!"
                raise ValueError(errStr)
            bSmote=1;
            
    nLabels=np.size(ClassLabelsIn)
    if np.squeeze(ClassLabelsIn).ndim>1:
        errStr="Error in ParameterRankingNGfraction: The array of class labels has to be 1d!"
        raise ValueError(errStr)
    if bSmote<0.5:
        if nLabels!=nData:
            errStr="Error in ParameterRankingNGfraction: The array of sample data must have the same length as the array of class labels!"
            raise ValueError(errStr)
    else:
        if nLabels!=nDataSmote:
            errStr="Error in ParameterRankingNGfraction: The array of SMOTE data must have the same length as the array of class labels!"
            raise ValueError(errStr)
    nKPIVTypes=np.size(TypeOfKPIV)
    if np.squeeze(TypeOfKPIV).ndim>1:
        errStr="Error in ParameterRankingNGfraction: The array of KPIV types has to be 1d!"
        raise ValueError(errStr)
    if nKPIVTypes!=nPar:
        errStr="Error in ParameterRankingNGfraction: The array of KPIV types must have the same length as the second dimension of the sample data!"
        raise ValueError(errStr)
    
    ##################### choose default values for inappropriate function
    ##################### input
    posContinuous=np.argwhere(TypeOfKPIV>0.5);
    posCategorical=np.argwhere(TypeOfKPIV<=0.5);
    if nBins<1:
        nBins=1+int(np.ceil(np.log2(nData)))
    if minCounts<0 or minCounts>nData:
        minCounts=int(0.01*nData)
        if minCounts<500:
            minCounts=500;
    if nSelected<2:
        nSelected=int(np.floor(nBins/2))
    if nSelected>nBins:
        nSelected=int(np.floor(nBins/2))
    if nWeights<1 or nWeights>nPar:
        nWeightsContinuous=int(np.floor(np.size(posContinuous)/5.0));
        nWeightsCategorical=int(np.floor(np.size(posCategorical)/5.0));
    if nWeightsContinuous<3 and np.size(posContinuous)>2:
        nWeightsContinuous=3;
    if nWeightsCategorical<3 and np.size(posCategorical)>2:
        nWeightsCategorical=3;
    if nTrials<1:
        nTrials=1;
    
    ##################### compute ranking criteria for each input parameter
    RankingCriteriaParRaw = np.array([])
    # for i in range(nPar):
    #     RankingCriteriaParRaw = np.append(RankingCriteriaParRaw, [np.array([{}])])     # Create array that don't override every entry
    if nTrials>1:
        RankingCriteriaTrial = np.array([])
        # for i in range(nPar*nTrials):
        #     RankingCriteriaTrial = np.append(RankingCriteriaTrial, [np.array([{}])])     # Create array that don't override every entry
    weightingFactor=np.ones((nPar,1));
    for n in range(0,nPar):
        if isinstance(DataIn,pd.DataFrame):
            DataTmp=DataIn.iloc[:,n].to_numpy();
        else:
            DataTmp=DataIn[:,n];
        if TypeOfKPIV[n]>0.5: # continuous KPIV
            if bSmote<0.5:
                pdfBin,histbins,ngFracBin,ngFracBinError,ngFracGlobal = HistNG.ComputeHistogramWithNGfractionAdapted(DataTmp,ClassLabelsIn,nBins,minCounts,statistcalMethod,bAdapted);
                ### compute adapted histogram and corresponding local NG fractions
            else:
                if isinstance(DataSmote,pd.DataFrame):
                    DataSmoteTmp=DataSmote.iloc[:,n].to_numpy();
                else:
                    DataSmoteTmp=DataSmote[:,n];
                pdfBin,histbins = HistNG.ComputeHistogramAdapted(DataTmp,nBins,minCounts,statistcalMethod,bAdapted);
                if statistcalMethod<0.5:
                    ngFracBin,ngFracBinError,ngFracGlobal = HistNG.ComputeNGfractionInBins(DataSmoteTmp,ClassLabelsIn,histbins);
                else:
                    ### alternative method with kernel density approximation
                    scalingDensity=0.1*np.std(DataSmoteTmp); # heuristsic value for RBF scaling
                    posNG=np.argwhere(ClassLabelsIn<0)[0];
                    ngFracBin,ngFracBinError=HistNG.LocalizedNGfractionInBins(histbins,DataSmoteTmp,posNG,scalingDensity);
        else: # categorical KPIV
            if bSmote<0.5:
                pdfBin,ngFracBin,ngFracBinError,ngFracGlobal = HistNG.ComputeHistogramWithNGfractionCategorical(DataTmp,ClassLabelsIn);
                ### compute histogram and corresponding local NG fractions for categorical KPIVs
            else:
                if isinstance(DataSmote,pd.DataFrame):
                    DataSmoteTmp=DataSmote.iloc[:,n].to_numpy();
                else:
                    DataSmoteTmp=DataSmote[:,n];
                pdfBin,ngFracBin,ngFracBinError,ngFracGlobal = HistNG.ComputeHistogramWithNGfractionCategorical(DataSmoteTmp,ClassLabelsIn);
                ### compute histogram and corresponding local NG fractions for categorical KPIVs
        ########### if the histogram of the continuous KPIV is degenerate, 
        ########### it is better to treat it as categorical
        if np.size(pdfBin)<nMinBins or (np.max(pdfBin)-np.min(pdfBin))/np.mean(pdfBin)<tolUniform:
            TypeOfKPIV[n]=0;
    
        ########### define a weighting factor for this KPIV derived from the
        ########### error of the local NG fraction
        posAllowed=np.argwhere(ngFracBin>1.0e-10)[0];
        if UseNGfracError<0.5:
            tmpVal=1.0
        if UseNGfracError>=0.5 and UseNGfracError<1.5:
            tmpVal=1.0/np.mean(ngFracBinError[posAllowed])
        if UseNGfracError>=1.5 and UseNGfracError<2.5:
            tmpVal=np.sqrt(np.size(pdfBin))/np.mean(ngFracBinError[posAllowed])
        if UseNGfracError>=2.5:
            tmpVal=np.sqrt(np.size(pdfBin))/np.mean(ngFracBinError[posAllowed]/ngFracBin[posAllowed])
        if np.isfinite(tmpVal):
            weightingFactor[n]=tmpVal
        
        ########### determine the ranking criteria for this KPIV
        if TypeOfKPIV[n]>0.5: # continuous KPIV
 #           RankingCriteriaParRaw[n] = NGfracFun.NGfractionRankingCriteriaContinuous(pdfBin,ngFracBin,ngFracBinError,histbins,ngFracGlobal,nSelected);
            tempResult = NGfracFun.NGfractionRankingCriteriaContinuous(pdfBin,ngFracBin,ngFracBinError,histbins,ngFracGlobal,nSelected);
        else: # categorical KPIV
 #           RankingCriteriaParRaw[n] = NGfracFun.NGfractionRankingCriteriaCategorical(pdfBin,ngFracBin,ngFracBinError,ngFracGlobal);
            tempResult = NGfracFun.NGfractionRankingCriteriaCategorical(pdfBin,ngFracBin,ngFracBinError,ngFracGlobal);
        RankingCriteriaParRaw=np.append(RankingCriteriaParRaw,tempResult);
    
        ########### determine the ranking criteria for different statistical
        ########### realizations of the underlying distribution, that is used
        ########### for quantifying the ranking error
        if nTrials>1:
            rngTrials = np.random.default_rng(4200)
#            RankingCriteriaTrial[n]=np.copy(RankingCriteriaParRaw[n]);
            CriteriaTrialTmp=np.copy(RankingCriteriaParRaw[n]);
            for l in range(1,nTrials):
                ngFracBinTrial=np.copy(ngFracBin); # original value is default
                for m in range(0,np.size(ngFracBin)): # for all bins
                    if TypeOfKPIV[n]>0.5: # continuous KPIV
                        histNTmp=int(pdfBin[m]*(histbins[m+1]-histbins[m])); # number of parts in the bin
                    else: # categorical KPIV
                        histNTmp=int(pdfBin[m]);
                    if histNTmp>0 and ngFracBin[m]>0 and ngFracBin[m]<1: # only possible for nonempty bins
                        nNGTmp=rngTrials.binomial(histNTmp,ngFracBin[m]); # number of NG parts according to corresponding binomial distribution
                        ngFracBinTrial[m]=nNGTmp/histNTmp; # resulting local NG fraction in this bin
                    if np.isnan(ngFracBinTrial[m]): # something went wrong
                        ngFracBinTrial[m]=ngFracBin[m]; # keep original value
                ### end of loop over m
                if TypeOfKPIV[n]>0.5: # continuous KPIV
#                    RankingCriteriaTrial[n+l*nPar] = NGfracFun.NGfractionRankingCriteriaContinuous(pdfBin,ngFracBinTrial,ngFracBinError,histbins,ngFracGlobal,nSelected);
                    tempResult = NGfracFun.NGfractionRankingCriteriaContinuous(pdfBin,ngFracBinTrial,ngFracBinError,histbins,ngFracGlobal,nSelected);
                                      # determine the ranking criteria this KPIV
                else: # categorical KPIV
#                    RankingCriteriaTrial[n+l*nPar] = NGfracFun.NGfractionRankingCriteriaCategorical(pdfBin,ngFracBinTrial,ngFracBinError,ngFracGlobal);
                    tempResult = NGfracFun.NGfractionRankingCriteriaCategorical(pdfBin,ngFracBinTrial,ngFracBinError,ngFracGlobal);
                CriteriaTrialTmp=np.append(CriteriaTrialTmp,tempResult)
          ### end of loop over l
            RankingCriteriaTrial=np.append(RankingCriteriaTrial,CriteriaTrialTmp)
       ### end of if
    ### end  of loop over n
    RankingCriteriaTrial=np.reshape(RankingCriteriaTrial,(nPar,nTrials))
    
    ##################### some of the continous KPIVs might have been converted
    ##################### to categorical
    posContinuous=np.argwhere(TypeOfKPIV>0.5)[:,0];
    posCategorical=np.argwhere(TypeOfKPIV<=0.5)[:,0];
    
    ##################### store ranking criteria in a matrix
    temp = NGfracFun.NGfractionRankingCriteriaStructureToArray(RankingCriteriaParRaw,weightingFactor);
    
    ##################### store ranking criteria with weigthing in structure
    RankingCriteriaPar = NGfracFun.NGfractionRankingCriteriaArrayToStructure(temp);
    
    #################### determine ranking according to criteria averaging and
    #################### majority voting
    RankingStructureAveragingContinuousTmp=InitRankingStructure()
    RankingStructureVotingContinuousTmp=InitRankingStructure()
    if np.size(posContinuous)>0:
        if xExtrema is not None: # we have an optional function input for the criteria limits
            ParameterRankingMajorityVoting,ParameterRankingAveraging,GlobalRankingCriterionVoting,GlobalRankingCriterionAveraging,RankingCriteriaLimitsContinuous = DetermineRanking(temp[posContinuous,:],nWeightsContinuous,nCriteriaContinuous,xExtrema);
        else:
            ParameterRankingMajorityVoting,ParameterRankingAveraging,GlobalRankingCriterionVoting,GlobalRankingCriterionAveraging,RankingCriteriaLimitsContinuous = DetermineRanking(temp[posContinuous,:],nWeightsContinuous,nCriteriaContinuous);
        
        #################### copy results to ranking structures for criteria 
        #################### averaging and majority voting
        # RankingStructureAveragingContinuousTmp = {
        #     "ParameterRanking": np.array((nPar,)),
        #     "GlobalCriterion": np.array((nPar,)),
        #     "nSignificant": 0,
        #     "errorSignificant": -1,
        #     "errorRankingKPIV": -1.0*np.ones((np.size(posContinuous),)),
        #     "errorRanking": -1,
        # }
        # RankingStructureVotingContinuousTmp = {
        #     "ParameterRanking": np.array((nPar,)),
        #     "GlobalCriterion": np.array((nPar,)),
        #     "nSignificant": 0,
        #     "errorSignificant": -1,
        #     "errorRankingKPIV": -1.0*np.ones((np.size(posContinuous),)),
        #     "errorRanking": -1,
        # }
        RankingStructureAveragingContinuousTmp["ParameterRanking"]=np.copy(ParameterRankingAveraging) #averaging
        RankingStructureAveragingContinuousTmp["GlobalCriterion"]=np.copy(GlobalRankingCriterionAveraging);
        RankingStructureVotingContinuousTmp["ParameterRanking"]=np.copy(ParameterRankingMajorityVoting) # voting
        RankingStructureVotingContinuousTmp["GlobalCriterion"]=np.copy(GlobalRankingCriterionVoting);
        
        ################### determine number of significant KPIVs for criteria 
        #################### averaging and majority voting (continuous KPIVs)
        xForFit=np.array(range(0,np.size(posContinuous)),ndmin=2)
        dummy=np.sort(-RankingStructureAveragingContinuousTmp["GlobalCriterion"]); # averaging
        _,_,nSignificantAveraging,_=Utility.FitTwoConnectedLinearCurves(xForFit,-dummy);
        RankingStructureAveragingContinuousTmp["nSignificant"]=nSignificantAveraging;
        dummy=np.sort(RankingStructureVotingContinuousTmp["GlobalCriterion"]); # voting
        _,_,nSignificantVoting,_=Utility.FitTwoConnectedLinearCurves(xForFit,-dummy);
        RankingStructureVotingContinuousTmp["nSignificant"]=nSignificantVoting;
    else:
        RankingCriteriaLimitsContinuous=np.array([])
    
    #################### determine ranking according to criteria averaging and
    #################### majority voting
    RankingStructureAveragingCategoricalTmp=InitRankingStructure()
    RankingStructureVotingCategoricalTmp=InitRankingStructure()
    if np.size(posCategorical)>0:
        ParameterRankingMajorityVoting,ParameterRankingAveraging,GlobalRankingCriterionVoting,GlobalRankingCriterionAveraging,RankingCriteriaLimitsCategorical = DetermineRanking(temp[posCategorical,:],nWeightsCategorical,nCriteriaCategorical);
        
        #################### copy results to ranking structures for criteria 
        #################### averaging and majority voting
        # RankingStructureAveragingCategoricalTmp = {
        #     "ParameterRanking": np.array((nPar,)),
        #     "GlobalCriterion": np.array((nPar,)),
        #     "nSignificant": 0,
        #     "errorSignificant": -1,
        #     "errorRankingKPIV": -1.0*np.ones((np.size(posCategorical),)),
        #     "errorRanking": -1,
        # }
        RankingStructureAveragingCategoricalTmp["ParameterRanking"]=np.copy(ParameterRankingAveraging); #averaging
        RankingStructureAveragingCategoricalTmp["GlobalCriterion"]=np.copy(GlobalRankingCriterionAveraging);
        # RankingStructureVotingCategoricalTmp = {
        #     "ParameterRanking": np.array((nPar,)),
        #     "GlobalCriterion": np.array((nPar,)),
        #     "nSignificant": 0,
        #     "errorSignificant": -1,
        #     "errorRankingKPIV": -1.0*np.ones((np.size(posCategorical),)),
        #     "errorRanking": -1,
        # }
        RankingStructureVotingCategoricalTmp["ParameterRanking"]=np.copy(ParameterRankingMajorityVoting); # voting
        RankingStructureVotingCategoricalTmp["GlobalCriterion"]=np.copy(GlobalRankingCriterionVoting);
        
        ################### determine number of significant KPIVs for criteria 
        ################### averaging and majority voting (categorical KPIVs)
        xForFit=np.array(range(0,np.size(posCategorical)),ndmin=2)
        dummy=np.sort(RankingStructureAveragingCategoricalTmp["GlobalCriterion"]); # averaging
        _,_,nSignificantAveraging,_=Utility.FitTwoConnectedLinearCurves(xForFit,-dummy);
        RankingStructureAveragingCategoricalTmp["nSignificant"]=nSignificantAveraging;
        dummy=np.sort(RankingStructureVotingCategoricalTmp["GlobalCriterion"]); # voting
        _,_,nSignificantVoting,_=Utility.FitTwoConnectedLinearCurves(xForFit,-dummy);
        RankingStructureVotingCategoricalTmp["nSignificant"]=nSignificantVoting;
    else:
        RankingCriteriaLimitsCategorical=np.array([])
    
    ################### determine error of ranking and of number of significant
    ################### KPIVs
    RankingStructureVotingContinuous=InitRankingStructure()
    RankingStructureAveragingContinuous=InitRankingStructure()
    RankingStructureVotingCategorical=InitRankingStructure()
    RankingStructureAveragingCategorical=InitRankingStructure()
    if nTrials>1:
        if np.size(posContinuous)>0:
            ############### determine error for continuous KPIVs
            if xExtrema is not None: # we have an optional function input for the criteria limits
                RankingStructureVotingContinuous,RankingStructureAveragingContinuous,RankingCriteriaPar[posContinuous] = DetermineRankingError(RankingCriteriaTrial[posContinuous,:],weightingFactor[posContinuous],
                nWeightsContinuous,nCriteriaContinuous,xExtrema);
            else:
                RankingStructureVotingContinuous,RankingStructureAveragingContinuous,RankingCriteriaPar[posContinuous] = DetermineRankingError(RankingCriteriaTrial[posContinuous,:],weightingFactor[posContinuous],
                nWeightsContinuous,nCriteriaContinuous);
    
        if np.size(posCategorical)>0:
            ############### determine error for categorical KPIVs
            RankingStructureVotingCategorical,RankingStructureAveragingCategorical,RankingCriteriaPar[posCategorical] = DetermineRankingError(RankingCriteriaTrial[posCategorical,:],weightingFactor[posCategorical],
                nWeightsCategorical,nCriteriaCategorical);
    
    else: # no error has been determined
        ############ fill structure with values indicating that no error has
        ############ been determined and copy values from temporary structure
    
        ############ for continuous KPIVs
        RankingStructureVotingContinuous["ParameterRanking"]=RankingStructureVotingContinuousTmp.ParameterRanking;
        RankingStructureVotingContinuous["nSignificant"]=RankingStructureVotingContinuousTmp.nSignificant;
        # RankingStructureVotingContinuous["errorSignificant"]=-1;
        # RankingStructureVotingContinuous["errorRankingKPIV"]=-1.0*np.ones((np.size(posContinuous),));
        # RankingStructureVotingContinuous["errorRanking"]=-1;
        RankingStructureAveragingContinuous["ParameterRanking"]=RankingStructureAveragingContinuousTmp.ParameterRanking;
        RankingStructureAveragingContinuous["nSignificant"]=RankingStructureAveragingContinuousTmp.nSignificant;
        # RankingStructureAveragingContinuous["errorSignificant"]=-1;
        # RankingStructureAveragingContinuous["errorRankingKPIV"]=-1.0*np.ones((np.size(posContinuous),));
        # RankingStructureAveragingContinuous["errorRanking"]=-1;
    
        ############ for categorical KPIVs
        RankingStructureVotingCategorical["ParameterRanking"]=RankingStructureVotingCategoricalTmp.ParameterRanking;
        RankingStructureVotingCategorical["nSignificant"]=RankingStructureVotingContinuousTmp.nSignificant;
        # RankingStructureVotingCategorical["errorSignificant"]=-1;
        # RankingStructureVotingCategorical["errorRankingKPIV"]=-1.0*np.ones((np.size(posCategorical),));
        # RankingStructureVotingCategorical["errorRanking"]=-1;
        RankingStructureAveragingCategorical["ParameterRanking"]=RankingStructureAveragingCategoricalTmp.ParameterRanking;
        RankingStructureAveragingCategorical["nSignificant"]=RankingStructureAveragingContinuousTmp.nSignificant;
        # RankingStructureAveragingCategorical["errorSignificant"]=-1;
        # RankingStructureAveragingCategorical["errorRankingKPIV"]=-1.0*np.ones((np.size(posCategorical),));
        # RankingStructureAveragingCategorical["errorRanking"]=-1;
    
    ################ copy values from temporary structure
    RankingStructureAveragingContinuous["GlobalCriterion"]=RankingStructureAveragingContinuousTmp["GlobalCriterion"];
    RankingStructureVotingContinuous["GlobalCriterion"]=RankingStructureVotingContinuousTmp["GlobalCriterion"];
    RankingStructureAveragingCategorical["GlobalCriterion"]=RankingStructureAveragingContinuousTmp["GlobalCriterion"];
    RankingStructureVotingCategorical["GlobalCriterion"]=RankingStructureVotingContinuousTmp["GlobalCriterion"];
    TypeOfKPIVModified=TypeOfKPIV;
    
    return (RankingStructureVotingContinuous,RankingStructureAveragingContinuous,
            RankingStructureVotingCategorical,RankingStructureAveragingCategorical,
            RankingCriteriaPar,RankingCriteriaLimitsContinuous,
            RankingCriteriaLimitsCategorical,TypeOfKPIVModified)
##############################################################################
###################### end ParameterRankingNGfraction ########################
##############################################################################


##############################################################################
############################# DetermineRanking ###############################
##############################################################################
def DetermineRanking(RankingCriteriaArray,nWeights=-1,nCriteriaSelected=4,xExtrema=np.empty((0,0))):
#DetermineRanking: Determine a ranking of the KPIVs by averaging several 
#ranking criteria and by majority voting
#
#   A ranking of the KPIVs is derived from several ranking criteria, which 
#   are based on the local NGfraction and the histogram of the KPIVs. 
#   Presently 7 ranking criteria have been defined for continuous KPIVs, 
#   but only a subset will be taken into account for the calculations. 
#   The different ranking criteria are combined into one value by two 
#   different methods, namely majority voting and averaging. For majority 
#   voting we sort the KPIVs in descending order according to their 
#   importance. This gives a different order for each ranking criterion. 
#   The first nWeights KPIVs are assigned with descending weights from 
#   nWeights to 1. The sum of these weights over all criteria establishes 
#   a ranking by majority voting. In the second method each ranking 
#   criterion is scaled to a certain range (usually [0,1]), so that they 
#   are comparable. Thus, the average over all ranking criteria establishes 
#   a ranking of the KPIVs by averaging.
#
#   function input:
#      RankingCriteriaArray: The ranking criteria for each KPIV as a 2d
#                            array with dimension (nPar,nCriteria), where 
#                            nPar is the number of KPIVs and nCriteria the 
#                            number of criteria that have been defined for
#                            continuous KPIVs.
#      nWeights: The number of KPIVs that should be taken into account 
#                for majority voting. It has to be smaller than or equal to
#                the number of KPIVs. If it is larger than nPar or 
#                smaller than 1, we set nWeights=nPar/5.
#      nCriteriaSelected: Number of criteria that should be taken into
#                         account for the determination of a ranking.
#      There are additional optional input arguments collected in varargin.
#      varargin{1}: A 2d array of size (2,nCriteria) with the minimum and 
#                 maximum value for each criterium, which are used to scale 
#                 the ranking criteria into the interval [0,1]. This might 
#                 be helpful to compare ranking criteria from different 
#                 times.
#
#   function output:
#      ParameterRankingMajorityVoting: ranking of the input parameter from 
#          majority voting. It has dimension (nPar,).
#      ParameterRankingAveraging: ranking of the input parameter from
#          GlobalRankingCriterionAveraging. It has dimension (nPar,).
#      GlobalRankingCriterionAveraging: average of all ranking criteria for 
#          each KPIV. It has dimension (nPar,).
#      GlobalRankingCriterionVoting: Added weights of all ranking criteria 
#          for each KPIV. It has dimension (nPar,).
#      RankingCriteriaLimits: A 2d array of size (2,nCriteria) with the  
#          minimum and maximum value for each criterium.
#
#   Exceptions:
#      RankingCriteriaArray empty: If there are no ranking criteria data,  
#               an exception is thrown with the message: 
#                     "The input array must not be empty!"
#      RankingCriteriaArray has wrong format: If the second dimension of 
#               the array has not the size of the existing ranking 
#               criteria, an exception is thrown with the message: 
#                     "The input array has the wrong format!"

    nCriteria=7; # presently 7 ranking criteria have been defined for 
                 # continuous KPIVs
    
    ##################### check for correct data format and input parameter
    shapeData=np.shape(RankingCriteriaArray)
    nPar=shapeData[0]
    try: n2 = shapeData[1]
    except: n2 = 0
    if nPar<1:
        errStr="Error in DetermineRanking: The input array must not be empty!"
        raise ValueError(errStr)
    if n2!=nCriteria:
        errStr="Error in DetermineRanking: The input array has the wrong format!"
        raise ValueError(errStr)
    
    ##################### choose default values for inappropriate function
    ##################### input
    if nWeights<1:
        nWeights=int(nPar/5);
    if nWeights>nPar:
        nWeights=int(nPar/5);
    if nCriteriaSelected>nCriteria:
        nCriteriaSelected=nCriteria;
    if nCriteriaSelected<0:
        nCriteriaSelected=nCriteria;

    ##################### determine a global ranking criterion by averaging
    GlobalRankingCriterionAveraging = np.zeros((nPar,), float)
    n1, n2 = 0, 0
    RankingCriteriaLimits = np.zeros((2, nCriteria))
    if xExtrema is not None:    # we have an optional function input
        shapexExtrema = np.shape(xExtrema)
        n1 = shapexExtrema[0]
        n2 = shapexExtrema[1]
        RankingCriteriaLimits[0,:] = np.amin(RankingCriteriaArray,0)   # otherwise take actual extrema for normalizing
        RankingCriteriaLimits[1,:] = np.amax(RankingCriteriaArray,0)
    if n1 != 2 or n2 != nCriteria: # optional input has not the expected size
        xExtrema = np.zeros((2, nCriteria))
        xExtrema[0,:] = np.amin(RankingCriteriaArray,0)   # otherwise take actual extrema for normalizing
        xExtrema[1,:] = np.amax(RankingCriteriaArray,0)
        RankingCriteriaLimits=xExtrema; # save extrema of the ranking criteria
    for m in range(0, nCriteriaSelected):
        tempScaled = (RankingCriteriaArray[:,m] - xExtrema[0,m]) / (xExtrema[1,m] - xExtrema[0,m])
        GlobalRankingCriterionAveraging=GlobalRankingCriterionAveraging+tempScaled;
    GlobalRankingCriterionAveraging=GlobalRankingCriterionAveraging/nCriteriaSelected;
    ParameterRankingAveraging = np.squeeze(np.argsort(-GlobalRankingCriterionAveraging)) # sort averaged criterion
    
    ##################### determinea a global ranking criterion by voting
    weights = np.arange(nWeights, 0, -1)    # descending weights, e.g. (5,4,3,2,1)
    GlobalRankingCriterionVoting = np.zeros((nPar,), float)
    for m in range(0, nCriteriaSelected):
        idxTmp = np.argsort(-RankingCriteriaArray[:,m])  # sort criterion
        GlobalRankingCriterionVoting[idxTmp[0:nWeights]] = GlobalRankingCriterionVoting[idxTmp[0:nWeights]] + weights 
                  # take only the nWeights largest and add the appropriate weights

    ParameterRankingMajorityVoting = np.squeeze(np.argsort(-GlobalRankingCriterionVoting))  # sort weighted parameter

    return ParameterRankingMajorityVoting,ParameterRankingAveraging,GlobalRankingCriterionVoting,GlobalRankingCriterionAveraging,RankingCriteriaLimits
##############################################################################
########################### end DetermineRanking #############################
##############################################################################


##############################################################################
########################### DetermineRankingError ############################
##############################################################################
def DetermineRankingError(RankingCriteriaTrial,weightingFactor,nWeights=-1,nCriteriaSelected=4,xExtrema=np.empty((0,0))):
#DetermineRankingError: Determine the error of the KPIV ranking derived  
#from averaging and majority voting
#
#   A ranking of the KPIVs is derived from several ranking criteria, which 
#   are based on the local NG fraction and the histogram of the KPIVs. This
#   is repeated for many different trials of the ranking criteria. The
#   standard deviation from all these trials allows to quantify the ranking
#   error.
#    
#   function input:
#      RankingCriteriaTrial: An array of criteria structures with size 
#                            (nPar,nTrials), where nPar is the number of 
#                            KPIVs and nTrials the number of trials. THe
#                            criteria structure is a Matlab structure that
#                            collects all ranking criteria that have been
#                            defined.
#      weightingFactor: The weighting factor for each KPIV that has to be 
#                       applied to the ranking criteria. The array must  
#                       have dimension (nPar,1) or (1,nPar).
#      nWeights: The number of KPIVs that should be taken into account 
#                for majority voting. It has to be smaller than or equal to
#                the number of KPIVs. If it is larger than nPar or 
#                smaller than 1, we set nWeights=nPar/5.
#      nCriteriaSelected: Number of criteria that should be taken into
#                         account for the determination of a ranking.
#      There are additional optional input arguments collected in varargin.
#      xExtrema: A 2d array of size (2,nCriteria) with the minimum and 
#                maximum value for each criterium, which are used to scale 
#                the ranking criteria into the interval [0,1]. This might 
#                be helpful to compare ranking criteria from different 
#                times.
#
#   function output:
#      RankingStructureMajorityOut: Information about the ranking of the 
#                                   KPIVs and its error derived from 
#                                   majority voting.
#      RankingStructureAveragingOut: Information about the ranking of the 
#                                    KPIVs and its error derived from 
#                                    averaging.
#         The ranking structure is a Matlab structure that collects the
#         results of the ranking and its error. The following quantities 
#         are contained:
#            ParameterRanking: The ranking of the KPIVs. It has dimension (nPar,).
#            GlobalCriterion: The combined ranking criteria for each KPIV, 
#                   which are the basis of the ranking. It has dimension (nPar,).
#            nSignificant: The number of significant KPIVs that have an
#                   influence on the NG fraction.
#            errorSignificant: The error of the number of significant KPIVs 
#                   estimated from statistical considerations.
#            errorRankingKPIV: The ranking error for each KPIV estimated 
#                   from statistical considerations.  It has dimension (nPar,).
#            errorRanking: The global ranking error estimated from 
#                   statistical considerations. It is defined as the mean
#                   of the ranking error of the significant KPIVs.
#      RankingCriteriaPar: The values of all ranking criteria with 
#                          weigthing for each KPIV. It has dimension
#                          (nPar,nCriteria).
#
#   Exceptions:
#      RankingCriteriaTrial empty: If there are no data for the ranking 
#               criteria, an exception is thrown with the message: 
#                     "The array of ranking criteria data must not be empty!"
#      nTrials<3: If the number of trials is smaller than 3 no standard 
#               deviation, and thus no ranking error can be determined.
#               Therefore, an exception is thrown with the message: 
#                     "There have to be at least 3 trials for the ranking 
#                      criteria!"
#      RankingCriteriaTrial is not ranking structure: If the elements of 
#               RankingCriteriaTrial are no Matlab structures of the ranking 
#               criteria format, an exception is thrown with the message: 
#                     "The elements of the array of ranking criteria are no
#                      ranking criteria structures!"
#      weightingFactor not 1d: If the array for the weighting factors is 
#               not 1d, an exception is thrown with the message: 
#                     "The array of weighting factors has to be 1d!"
#      length(weightingFactor)~=nPar: If the number of KPIVs of the SMOTE 
#               data does not fit to the number of KPIVs, an exception is 
#               thrown with the message: 
#                     "The number of KPIVs must be the same for the ranking
#                      criteria and weighting factors!"
    nCriteria=7; # presently 7 ranking citeria have been defined
    
    ##################### check for correct data format and input parameter
    shapeData=np.shape(RankingCriteriaTrial)
    nPar=shapeData[0]
    try: nTrials = shapeData[1]
    except: nTrials = 1
    if nPar<1:
        errStr="Error in DetermineRankingError: The array of ranking criteria data must not be empty!"
        raise ValueError(errStr)
    if nTrials<3:
        errStr="Error in DetermineRankingError: There have to be at least 3 trials for the ranking criteria!"
        raise ValueError(errStr)
    try:
        NGfracFun.NGfractionRankingCriteriaStructureToArray(RankingCriteriaTrial[:,1]);
    except:
        errStr="Error in DetermineRankingError: The elements of the array of ranking criteria are no ranking criteria structures!"
        raise ValueError(errStr)
    shapeData=np.shape(weightingFactor)
    n1=shapeData[0]
    try: n2 = shapeData[1]
    except: n2 = 1
    if n1==1 and n2>1: # weightingFactor is a row vector
        n1=n2;
        n2=1;
        weightingFactor=np.transpose(weightingFactor)
    if n2!=1:
        errStr="Error in DetermineRankingError: The array of weighting factors has to be 1d!"
        raise ValueError(errStr)
    if n1!=nPar:
        errStr="Error in DetermineRankingError: The number of KPIVs must be the same for the ranking criteria and weighting factors!"
        raise ValueError(errStr)
    
    ##################### choose default values for inappropriate function
    ##################### input
    if nWeights<1:
        nWeights=np.floor(nPar/5);
    if nWeights>nPar:
        nWeights=np.floor(nPar/5);
    if nCriteriaSelected<2:
        nCriteriaSelected=2;
    if nCriteriaSelected>nCriteria:
        nCriteriaSelected=nCriteria;
    
    ############ determine ranking for many trials
    nSignificantMajTmp=np.zeros([nTrials,1]);
    RankingMajTrials=np.zeros([nPar,nTrials]); 
    nSignificantAvgTmp=np.zeros([nTrials,1]);
    RankingAvgTrials=np.zeros([nPar,nTrials]); 
    RankingCriteriaArray=np.zeros([nPar,nCriteria]);
    xForFit=np.array(range(0,nPar),ndmin=2)
    for l in range(0,nTrials):
        ######### 
        temp = NGfracFun.NGfractionRankingCriteriaStructureToArray(RankingCriteriaTrial[:,l],weightingFactor);
        RankingCriteriaArray=RankingCriteriaArray+temp;
        if xExtrema is not None:    # we have an optional function input
            RankingMajTmp,RankingAvgTmp,GlobalCriterionMajTmp,GlobalCriterionAvgTmp,_ = DetermineRanking(temp,nWeights,nCriteriaSelected,xExtrema);
        else:
            RankingMajTmp,RankingAvgTmp,GlobalCriterionMajTmp,GlobalCriterionAvgTmp,_ = DetermineRanking(temp,nWeights,nCriteriaSelected);
        dummy=np.sort(-GlobalCriterionMajTmp);
        _,_,nSignificantMajTmp[l],_=Utility.FitTwoConnectedLinearCurves(xForFit,-dummy); # number of significvant parameter from fit
        for m in range(0,nPar):
            posTmp=np.argwhere(RankingMajTmp==m);
            RankingMajTrials[m,l]=np.squeeze(posTmp);
        dummy=np.sort(-GlobalCriterionAvgTmp);
        _,_,nSignificantAvgTmp[l],_=Utility.FitTwoConnectedLinearCurves(xForFit,-dummy); # number of significvant parameter from fit
        for m in range(0,nPar):
            posTmp=np.argwhere(RankingAvgTmp==m);
            RankingAvgTrials[m,l]=np.squeeze(posTmp);
            
    RankingCriteriaArray=RankingCriteriaArray/nTrials;
    RankingCriteriaPar = NGfracFun.NGfractionRankingCriteriaArrayToStructure(RankingCriteriaArray);
    if xExtrema is not None:    # we have an optional function input
        RankingMajTmp,RankingAvgTmp,GlobalCriterionMajTmp,GlobalCriterionAvgTmp,_ = DetermineRanking(temp,nWeights,nCriteriaSelected,xExtrema);
    else:
        RankingMajTmp,RankingAvgTmp,GlobalCriterionMajTmp,GlobalCriterionAvgTmp,_ = DetermineRanking(temp,nWeights,nCriteriaSelected);

    ############# determine error of significant parameter and ranking for
    ############# majority voting
    RankingStructureMajorityOut = {
        "ParameterRanking": np.array((nPar,)),
        "GlobalCriterion": np.array((nPar,)),
        "nSignificant": 0,
        "errorSignificant": 0,
        "errorRankingKPIV": np.array((nPar,)),
        "errorRanking": 0,
    }
    RankingStructureMajorityOut["nSignificant"]=np.floor(np.mean(nSignificantMajTmp)+0.5); # voting
    RankingStructureMajorityOut["errorSignificant"]=np.std(nSignificantMajTmp);
    RankingStructureMajorityOut["errorRankingKPIV"]=np.std(RankingMajTrials,axis=1);
    ParameterRankingMajorityVoting=np.argsort(np.mean(RankingMajTrials,axis=1));
    RankingStructureMajorityOut["ParameterRanking"]=ParameterRankingMajorityVoting; 
    RankingStructureMajorityOut["errorRanking"]=np.mean(RankingStructureMajorityOut["errorRankingKPIV"][ParameterRankingMajorityVoting[0:int(RankingStructureMajorityOut["nSignificant"])]]);
    RankingStructureMajorityOut["GlobalCriterion"]=GlobalCriterionAvgTmp;

    ############# determine error of significant parameter and ranking for
    ############# averaging
    RankingStructureAveragingOut = {
        "ParameterRanking": np.array((nPar,)),
        "GlobalCriterion": np.array((nPar,)),
        "nSignificant": 0,
        "errorSignificant": 0,
        "errorRankingKPIV": np.array((nPar,)),
        "errorRanking": 0,
    }
    RankingStructureAveragingOut["nSignificant"]=np.floor(np.mean(nSignificantAvgTmp)+0.5); # averaging
    RankingStructureAveragingOut["errorSignificant"]=np.std(nSignificantAvgTmp);
    RankingStructureAveragingOut["errorRankingKPIV"]=np.std(RankingAvgTrials,axis=1);
    ParameterRankingAveraging=np.argsort(np.mean(RankingAvgTrials,axis=1));
    RankingStructureAveragingOut["ParameterRanking"]=ParameterRankingAveraging; 
    RankingStructureAveragingOut["errorRanking"]=np.mean(RankingStructureAveragingOut["errorRankingKPIV"][ParameterRankingAveraging[0:int(RankingStructureAveragingOut["nSignificant"])]]);
    RankingStructureAveragingOut["GlobalCriterion"]=GlobalCriterionMajTmp;
    
    return RankingStructureMajorityOut,RankingStructureAveragingOut,RankingCriteriaPar
##############################################################################
######################### end DetermineRankingError ##########################
##############################################################################


##############################################################################
########################## JudgeRankingReliability ###########################
##############################################################################
def JudgeRankingReliability(rankingError,nSignificantError,limitsRanking,limitsSignificant):
#Determine a qualitative judgement about the reliability of the ranking
#
#   Based on the average ranking error and the error of the significant 
#   KPIVs a qualitative judgement for the reliability of the ranking is
#   derived ranging from "very good", "good", "medium", and "bad" to 
#   "very bad".
#
#   function input:
#      rankingError: Average ranking error of the significant KPIVs.
#      nSignificantError: Error of the number of significant KPIVs.
#      limitsRanking: A 2d array of size (2,1) with the limiting values of 
#                     the ranking error, which separate good, medium and 
#                     bad reliability of the ranking.
#      limitsSignificant: A 2d array of size (2,1) with the limiting values 
#                         of the error for the number of significant KPIVs, 
#                         which separate good, medium and bad reliability 
#                         of the ranking.
#
#   function output:
#      ReliabilityJudgement: Qualitative judgement of the ranking
#                            reliability as a string. Possible values are
#                            "very good", "good", "medium", "bad" and
#                            "very bad".
#
#   Exceptions:
#      limitsRanking not 1d: If the array for the limiting values of the 
#               ranking error is not 1d, an exception is thrown with the 
#               message: 
#                     "The array for the limiting values of the ranking 
#                      error has to be 1d!"
#      numel(limitsRanking)~=2: If the size of the limiting values of the 
#               ranking error is not 2, an exception is thrown with the 
#               message: 
#                     "The array for the limiting values of the ranking 
#                      error must have 2 elements!"
#      limitsSignificant not 1d: If the array for the limiting values of 
#               the error for the number of significant KPIVs is not 1d, an 
#               exception is thrown with the message: 
#                     "The array for the limiting values of the error for 
#                      the number of significant KPIVs has to be 1d!"
#      numel(limitsSignificant)~=2: If the size of the limiting values of 
#               the error for the number of significant KPIVs is not 2, an 
#               exception is thrown with the message: 
#                     "The array for the limiting values of the error for 
#                      the number of significant KPIVs must have 2 elements!"

##################### check for correct data format and input parameter
    if np.squeeze(limitsRanking).ndim>1:
        errStr="Error in JudgeRankingReliability: The array for the limiting values of the ranking error has to be 1d!"
        raise ValueError(errStr)
    limitsRanking=np.squeeze(limitsRanking)
    n1=np.size(limitsRanking);
    if n1!=2:
        errStr="Error in JudgeRankingReliability: The array for the limiting values of the ranking error must have 2 elements!"
        raise ValueError(errStr)
    if np.squeeze(limitsSignificant).ndim>1:
        errStr="Error in JudgeRankingReliability: The array for the limiting values of the error for the number of significant KPIVs has to be 1d!"
        raise ValueError(errStr)
    limitsSignificant=np.squeeze(limitsSignificant)
    n1=np.size(limitsSignificant);
    if n1!=2:
        errStr="Error in JudgeRankingReliability: The array for the limiting values of the error for the number of significant KPIVs must have 2 elements!"
        raise ValueError(errStr)

    ##################### choose default values for inappropriate function
    ##################### input
    limitsRanking=abs(limitsRanking);
    if limitsRanking[0]>limitsRanking[1]:
        dummy=limitsRanking[0];
        limitsRanking[0]=limitsRanking[1];
        limitsRanking[1]=dummy;
    limitsSignificant=abs(limitsSignificant);
    if limitsSignificant[0]>limitsSignificant[1]:
        dummy=limitsSignificant(0);
        limitsSignificant[0]=limitsSignificant[1]
        limitsSignificant[1]=dummy;
    
    ##################### determine qualitative judgement for ranking
    ##################### reliability
    rankingError=abs(rankingError);
    nSignificantError=abs(nSignificantError);
    if rankingError<limitsRanking[0] and nSignificantError<limitsSignificant[0]:
        ReliabilityJudgement="very good";
    if rankingError>=limitsRanking[0] and rankingError<limitsRanking[1] and nSignificantError<limitsSignificant[0]:
        ReliabilityJudgement="good";
    if rankingError<limitsRanking[0] and nSignificantError>=limitsSignificant[0] and nSignificantError<limitsSignificant[1]:
        ReliabilityJudgement="good";
    if rankingError>=limitsRanking[0] and rankingError<limitsRanking[1] and nSignificantError>=limitsSignificant[0] and nSignificantError<limitsSignificant[1]:
        ReliabilityJudgement="medium";
    if rankingError>=limitsRanking[1] and nSignificantError<limitsSignificant[1]:
        ReliabilityJudgement="bad";
    if rankingError<limitsRanking[1] and nSignificantError>=limitsSignificant[1]:
        ReliabilityJudgement="bad";
    if rankingError>=limitsRanking[1] and nSignificantError>=limitsSignificant[1]:
        ReliabilityJudgement="very bad";
    
    return ReliabilityJudgement
##############################################################################
######################## end JudgeRankingReliability #########################
##############################################################################


##############################################################################
########################### InitRankingStructure #############################
##############################################################################
def InitRankingStructure():
#Inizialize the structure for the KPIV ranking with default values.
#
#   Since sometimes not all of the members of the ranking structure can be
#   calculated, it is convenient to have a function that initializes all
#   members with default values
#
#   function input:
#      nPar
#
#   function output:
#      RankStruct: A ranking structure with default values for the member
#                  variables.
#
#   Exceptions:
#      No exceptions are thrown

    RankStruct = {
        "ParameterRanking": np.array([]),
        "GlobalCriterion": np.array([]),
        "nSignificant": 0,
        "errorSignificant": -1,
        "errorRankingKPIV": np.array([]),
        "errorRanking": -1,
    }
    return RankStruct
##############################################################################
######################### end InitRankingStructure ###########################
##############################################################################


##############################################################################
######################## InitOutputStructureRanking ##########################
##############################################################################
def InitOutputStructureRanking():
#Inizialize the structure for the KPIV ranking with default values.
#
#   Since sometimes not all of the members of the ranking structure can be
#   calculated, it is convenient to have a function that initializes all
#   members with default values
#
#   function input:
#      nPar
#
#   function output:
#      RankStruct: A ranking structure with default values for the member
#                  variables.
#
#   Exceptions:
#      No exceptions are thrown

    OutputStruct = {
        "KPIVRanking": np.array([]),
        "RankingError": np.array([]),
        "nSignificant": 0,
        "nSignificantError": -1,
        "rankingErrorAverage": -1,
        "reliability": 'not determined',
    }
    return OutputStruct
##############################################################################
###################### end InitOutputStructureRanking ########################
##############################################################################


